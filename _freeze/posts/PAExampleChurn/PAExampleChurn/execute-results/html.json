{
  "hash": "52cff08fd5e24dcf0b6e6661884f8fe8",
  "result": {
    "markdown": "---\ntitle: \"People Analytics Using R - Employee Churn- An Example\"\nauthor: \"Lyndon Sundmark, MBA\"\ndate: \"2016-03-27\"\ncategories: [HR Analytics]\n---\n\n\n# Introduction\n\nThis is the second is a series of blog articles on using R for doing People Analytics. The first was my last article:\n\n<https://www.linkedin.com/pulse/people-analytics-example-using-r-lyndon-sundmark-mba?trk=prof-post>\n\nIt gave an example of People Analytics being applied to absenteeism data. Lets now take a look at another HR example- this time **employee churn**. (Once again, the example is intended to be illustrative, not necessarily robust or best practices)\n\nYou may be asking what is Employee Churn? In a word -\"turnover'- its when employees leave the organization. In another word-\"terminates\", whether is be voluntary or involuntary. In the widest sense churn/turnover is concerned both the calculation of rates of people leaving the organization and the individual terminates themselves.\n\nMost of the focus in the past has been on the 'rates', not on the individual terminates.We calaculate past rates or turnover in an attempt to predict future turnover rates. And indeed it is important to do that and to continue to do so. Data warehousing tools are very powerful in this regard to slice and dice this data efficiently over different time periods at different levels of granularity. **BUT** it is only half the picture. These rates only show the impact of churn/turnover in the 'aggregate'. In addition to this you might be interested in predicting exactly 'who' or 'which employees' exactly may be at high risk for leaving the organization. Hence the reason for being interested in the 'individual' records in addition to the aggegrate.\n\nStatistically speaking, 'churn' is 'churn' regardless of context. Its when a member of a population leaves a population. One of the examples your will see in Microsoft AzureML and in many data science textbooks out there is 'customer' churn. This is from the marketing context. In many businesses such a cell phone companies and others, it is far harder to generate and attract new customers than it is to keep old ones. So businesses want to do what they can to keep existing customers. When they leave, that is 'customer churn' for that particular company.\n\nThere is applicability of this kind of thinking and mindset to Human Resources in an organization as well. It is far less expensive to 'keep' good employees once you have them, then the cost of attracting and training new ones. Hmmmmm- a marketing principle that applies to the management of human resources, and a data science set of algorithms that can help determine whether there are patterns of churn in our data that could help predict future churn.\n\nHR truly needs to start thinking outside of its traditional thinking and methodologies to powerfully address the HR challenges and issues in the future\n\nAs I indicated in my previous article (mentioned above)- on a personal level I like to think of People Analytics as when the data science process is applied to HR information. For that reason i would to **revisit** what that process is and use it as the framework to guide the rest of the example illustrated in this blog article.\n\n# The Data Science Process Revisited\n\n1.  **Define a goal** ,as mentioned above, means identifying first what HR management business problem you are trying to solve. Without a problem/issue we don't have a goal.\n2.  **Collect and Manage data.** At its simplest, you want a 'dataset' of information perceived to be relevant to the problem. The collection and management of data could be a simple extract from the corporate Human Resource Information System, or an output from an elaborate Data Warehousing/Business Intelligence tool used on HR information. For purpose of this blog article illustration we will use a simple CSV file. It also involves exploring the data both for data quality issues, and for an initial look at what the data may be telling you\n3.  **Build The Model.** This step really means, after you have defined the HR business problem or goal you are trying to achieve, you pick a data mining approach/tool that is designed to address that type of problem. With Employee Churn you are trying to predict who might leave as contrasted from those that stay. The business problem/goal determine the appropriate data mining tools to consider. Not exhaustive as a list, but common data mining approaches used in modelling are classification,regression, anomaly detection, time series, clustering, association analyses to name a few. These approaches take information/data as inputs , run them through statistical algorithms, and produce output.\n4.  **Evaluate and Critique Model.** Each data mining approach can have many different statistical algorithms to bring to bear on the data. The evaluation is both what algorithms provide the most consistent accurate predictions on new data, and do we have all the relevant data or do we need more types of data to increase predictive accuracy of model on new data. This can be necessarily repetitive and circular activity over time to improve the model\n5.  **Present Results And Document.** When we have gotten out model to an acceptable ,useful predictive level, we document our activity and present results. The definition of acceptable and useful is really relative to the organization, but in all cases would mean , results show improvement over what would have been otherwise. The principle behind data 'science' like any science, is that with the same data, people should be able to reproduce our findings/ results.\n6.  **Deploy Model.** The whole purpose of building the model ( which is on existing data) is to:\n\n-   use the model on future data when it becomes available, to predict or prevent something from happening before it occurs or\n-   to better understand our existing business problem to tailor more specific responses\n\n# Step 1 -Define The Goal\n\nOur hypothetical company found that its previous application of People Analytics- applying the data science process to organizational absenteeism as an issue yielded some valuable insights that are now impacting their decision making in the future on how they will address it.\n\nIt now wants to apply these same data science principles and steps to another HR issue- employee churn. It realizes when good people leave, it costs far more to replace them than providing some incentives to keep them. So it would like to be data driven in the HR decisions it makes with respect to employee retention\n\nThe following questions are among the ones they would like answered:\n\n1.  What proportion of our staff are leaving?\n2.  Where is it occuring?\n3.  How does Age and Length of Service affect termination?\n4.  What, if anything, else contributes to it?\n5.  Can we predict future terminations?\n6.  If so, how well can we predict?\n\n# Step 2 - Collect And Manage The Data\n\nOften the data to analyze the problem starts with what is currently readily available. After some initial prototyping of predictive models, ideas surface for additional data collection to further refine the model. Since this is first stab at this , the organization uses only what is readily available.\n\nAfter consulting with their HRIS staff, they found that they have access to the following information:\n\n-   EmployeeID\n-   Record Date\n-   Birth Date\n-   Original Hire Date\n-   Termination Date (if terminated)\n-   Age\n-   Length of Service\n-   City\n-   Department\n-   Job title\n-   Store Name\n-   Gender\n-   termination reason\n-   termination type (voluntary or involuntary)\n-   Status Year - year of data\n-   Status - ACTIVE or TERMINATED during status year\n-   Business Unit -Stores or Head Office\n\nThe company found out that they have 10 years of good data -from 2006 to 2015. It wants to use 2006-2014 as training data and use 2015 as the data to test on. The data consists of\n\n-   a snapshot of all active employees at the end of each of those years combined with\n-   terminations that occcured during each of those years.\n\nTherefore each year will have records that have either a status of 'active' or 'terminated'. Of the above information items listed, the 'STATUS' one is the 'dependent' variable- a category to be predicted. Many of others are the independent varibles -'potential' predictors.\n\n## First Look at The Data- The Structure\n\nLets load in the data. (By the way, the data below is totally **contrived**)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load an R data frame.\nlibrary(readr)\nMFG10YearTerminationData <- read_csv(\"MFG10YearTerminationData.csv\", \n    col_types = cols(gender_full = col_factor(levels = c(\"Male\", \n        \"Female\")), STATUS = col_factor(levels = c(\"ACTIVE\", \n        \"TERMINATED\")), BUSINESS_UNIT = col_factor(levels = c(\"HEADOFFICE\", \n        \"STORES\"))))\nMYdataset <- MFG10YearTerminationData\nstr(MYdataset)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nspc_tbl_ [49,653 × 18] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n $ EmployeeID         : num [1:49653] 1318 1318 1318 1318 1318 ...\n $ recorddate_key     : chr [1:49653] \"12/31/2006 0:00\" \"12/31/2007 0:00\" \"12/31/2008 0:00\" \"12/31/2009 0:00\" ...\n $ birthdate_key      : Date[1:49653], format: \"1954-01-03\" \"1954-01-03\" ...\n $ orighiredate_key   : Date[1:49653], format: \"1989-08-28\" \"1989-08-28\" ...\n $ terminationdate_key: Date[1:49653], format: \"1900-01-01\" \"1900-01-01\" ...\n $ age                : num [1:49653] 52 53 54 55 56 57 58 59 60 61 ...\n $ length_of_service  : num [1:49653] 17 18 19 20 21 22 23 24 25 26 ...\n $ city_name          : chr [1:49653] \"Vancouver\" \"Vancouver\" \"Vancouver\" \"Vancouver\" ...\n $ department_name    : chr [1:49653] \"Executive\" \"Executive\" \"Executive\" \"Executive\" ...\n $ job_title          : chr [1:49653] \"CEO\" \"CEO\" \"CEO\" \"CEO\" ...\n $ store_name         : chr [1:49653] \"035\" \"035\" \"035\" \"035\" ...\n $ gender_short       : chr [1:49653] \"M\" \"M\" \"M\" \"M\" ...\n $ gender_full        : Factor w/ 2 levels \"Male\",\"Female\": 1 1 1 1 1 1 1 1 1 1 ...\n $ termreason_desc    : chr [1:49653] \"Not Applicable\" \"Not Applicable\" \"Not Applicable\" \"Not Applicable\" ...\n $ termtype_desc      : chr [1:49653] \"Not Applicable\" \"Not Applicable\" \"Not Applicable\" \"Not Applicable\" ...\n $ STATUS_YEAR        : num [1:49653] 2006 2007 2008 2009 2010 ...\n $ STATUS             : Factor w/ 2 levels \"ACTIVE\",\"TERMINATED\": 1 1 1 1 1 1 1 1 1 1 ...\n $ BUSINESS_UNIT      : Factor w/ 2 levels \"HEADOFFICE\",\"STORES\": 1 1 1 1 1 1 1 1 1 1 ...\n - attr(*, \"spec\")=\n  .. cols(\n  ..   EmployeeID = col_double(),\n  ..   recorddate_key = col_character(),\n  ..   birthdate_key = col_date(format = \"\"),\n  ..   orighiredate_key = col_date(format = \"\"),\n  ..   terminationdate_key = col_date(format = \"\"),\n  ..   age = col_double(),\n  ..   length_of_service = col_double(),\n  ..   city_name = col_character(),\n  ..   department_name = col_character(),\n  ..   job_title = col_character(),\n  ..   store_name = col_character(),\n  ..   gender_short = col_character(),\n  ..   gender_full = col_factor(levels = c(\"Male\", \"Female\"), ordered = FALSE, include_na = FALSE),\n  ..   termreason_desc = col_character(),\n  ..   termtype_desc = col_character(),\n  ..   STATUS_YEAR = col_double(),\n  ..   STATUS = col_factor(levels = c(\"ACTIVE\", \"TERMINATED\"), ordered = FALSE, include_na = FALSE),\n  ..   BUSINESS_UNIT = col_factor(levels = c(\"HEADOFFICE\", \"STORES\"), ordered = FALSE, include_na = FALSE)\n  .. )\n - attr(*, \"problems\")=<externalptr> \n```\n:::\n\n```{.r .cell-code}\nlibrary(plyr)\nlibrary(dplyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'dplyr'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:plyr':\n\n    arrange, count, desc, failwith, id, mutate, rename, summarise,\n    summarize\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n:::\n:::\n\n\n## Second Look at The Data- Data Quality\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(MYdataset)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   EmployeeID   recorddate_key     birthdate_key        orighiredate_key    \n Min.   :1318   Length:49653       Min.   :1941-01-15   Min.   :1989-08-28  \n 1st Qu.:3360   Class :character   1st Qu.:1958-05-28   1st Qu.:1995-06-02  \n Median :5031   Mode  :character   Median :1968-12-04   Median :2000-03-31  \n Mean   :4859                      Mean   :1969-01-09   Mean   :2000-09-04  \n 3rd Qu.:6335                      3rd Qu.:1979-07-18   3rd Qu.:2005-10-13  \n Max.   :8336                      Max.   :1994-12-31   Max.   :2013-12-11  \n terminationdate_key       age        length_of_service  city_name        \n Min.   :1900-01-01   Min.   :19.00   Min.   : 0.00     Length:49653      \n 1st Qu.:1900-01-01   1st Qu.:31.00   1st Qu.: 5.00     Class :character  \n Median :1900-01-01   Median :42.00   Median :10.00     Mode  :character  \n Mean   :1916-05-10   Mean   :42.08   Mean   :10.43                       \n 3rd Qu.:1900-01-01   3rd Qu.:53.00   3rd Qu.:15.00                       \n Max.   :2015-12-30   Max.   :65.00   Max.   :26.00                       \n department_name     job_title          store_name        gender_short      \n Length:49653       Length:49653       Length:49653       Length:49653      \n Class :character   Class :character   Class :character   Class :character  \n Mode  :character   Mode  :character   Mode  :character   Mode  :character  \n                                                                            \n                                                                            \n                                                                            \n gender_full    termreason_desc    termtype_desc       STATUS_YEAR  \n Male  :23755   Length:49653       Length:49653       Min.   :2006  \n Female:25898   Class :character   Class :character   1st Qu.:2008  \n                Mode  :character   Mode  :character   Median :2011  \n                                                      Mean   :2011  \n                                                      3rd Qu.:2013  \n                                                      Max.   :2015  \n        STATUS         BUSINESS_UNIT  \n ACTIVE    :48168   HEADOFFICE:  585  \n TERMINATED: 1485   STORES    :49068  \n                                      \n                                      \n                                      \n                                      \n```\n:::\n:::\n\n\nA cursory look at the above summary doesnt have anything jump out as being data quality issues.\n\n## Third Look at the Data - Generally What Is The Data Telling Us?\n\nEarlier we had indicated that we had both active records at end of year and terminates during the year for each of 10 years going from 2006 to 2015. To have a population to model from (to differentiate ACTIVES from TERMINATES) we have to include both status types .\n\nIts useful then to get a baseline of what percent/proportion the terminates are of the entire population. It also answers our first question. Let's look at that next.\n\n**What proportion of our staff are leaving?**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nStatusCount<- as.data.frame.matrix(MYdataset %>%\n                              group_by(STATUS_YEAR) %>%\n                              select(STATUS) %>%\n                              table())\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nAdding missing grouping variables: `STATUS_YEAR`\n```\n:::\n\n```{.r .cell-code}\nStatusCount$TOTAL<-StatusCount$ACTIVE + StatusCount$TERMINATED\nStatusCount$PercentTerminated <-StatusCount$TERMINATED/(StatusCount$TOTAL)*100\nStatusCount\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     ACTIVE TERMINATED TOTAL PercentTerminated\n2006   4445        134  4579          2.926403\n2007   4521        162  4683          3.459321\n2008   4603        164  4767          3.440319\n2009   4710        142  4852          2.926628\n2010   4840        123  4963          2.478340\n2011   4972        110  5082          2.164502\n2012   5101        130  5231          2.485184\n2013   5215        105  5320          1.973684\n2014   4962        253  5215          4.851390\n2015   4799        162  4961          3.265471\n```\n:::\n\n```{.r .cell-code}\nmean(StatusCount$PercentTerminated)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2.997124\n```\n:::\n:::\n\n\nIt looks like it ranges from 1.97 to 4.85% with an average of 2.99%\n\n**Where are the terminations occurring?**\n\nLets look at some charts\n\n**By Business Unit**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nggplot() + geom_bar(aes(y = ..count..,x =as.factor(BUSINESS_UNIT),fill = as.factor(STATUS)),data=MYdataset,position = position_stack())\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: The dot-dot notation (`..count..`) was deprecated in ggplot2 3.4.0.\nℹ Please use `after_stat(count)` instead.\n```\n:::\n\n::: {.cell-output-display}\n![](PAExampleChurn_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\nIt looks like terminates is the last 10 years have predominantly occurred in the STORES business unit. Only 1 terminate in HR Technology which is in the head office.\n\nLets explore just the terminates for a few moments.\n\n**Just Terminates By Termination Type And Status Year**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nTerminatesData<- as.data.frame(MYdataset %>%\n                          filter(STATUS==\"TERMINATED\"))\n\nggplot() + geom_bar(aes(y = ..count..,x =as.factor(STATUS_YEAR),fill = as.factor(termtype_desc)),data=TerminatesData,position = position_stack())\n```\n\n::: {.cell-output-display}\n![](PAExampleChurn_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\nGenerally most terminations seem to be voluntary year by year,except in the most recent years where is are some involutary terminates.\n\n**Just Terminates By Status Year and Termination Reason**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() + geom_bar(aes(y = ..count..,x =as.factor(STATUS_YEAR),fill = as.factor(termreason_desc)),data=TerminatesData, position = position_stack())\n```\n\n::: {.cell-output-display}\n![](PAExampleChurn_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\nIt seems that there were layoffs in 2014 and 2015 which accounts for the involuntary terminates.\n\n**Just Terminates By Termination Reason and Department**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() + geom_bar(aes(y = ..count..,x =as.factor(department_name),fill = as.factor(termreason_desc)),data=TerminatesData,position = position_stack())+\n  theme(axis.text.x=element_text(angle=90,hjust=1,vjust=0.5))\n```\n\n::: {.cell-output-display}\n![](PAExampleChurn_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\nWhen we look at the terminate by Department, a few thing stick out. Customer Service has a much larger proportion of resignation compared to other departments. And retirement in general is high is a number of departments.\n\n**How does Age and Length of Service affect termination?**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(caret)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: lattice\n```\n:::\n\n```{.r .cell-code}\nfeaturePlot(x=MYdataset[,6:7],y=MYdataset$STATUS,plot=\"density\",auto.key = list(columns = 2))\n```\n\n::: {.cell-output-display}\n![](PAExampleChurn_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\nDensity plots show some interesting things. For terminates there is some elevation from 20 to 30 and a spike at 60. For length of service there are 5 spikes. One around 1 year, another one around 5 years, and a big one around 15 year, and a couple at 20 and 25 years.\n\n**Age and Length of Service Distributions By Status**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfeaturePlot(x=MYdataset[,6:7],y=MYdataset$STATUS,plot=\"box\",auto.key = list(columns = 2))\n```\n\n::: {.cell-output-display}\n![](PAExampleChurn_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\nBoxplots show high average age for terminates as compared to active. Length of service shows not much difference between active and terminated.\n\nThat's a brief general look at some of what the data is telling us. Our next step of course is model building.\n\n# Step 3 - Build The Model\n\nSimilar to the last blog article, it should be mentioned again that for building models, we never want to use **all** our data to build the model. This can lead to overfitting- where it might be able to predict well on current data that it sees as is built on, but may not predict well on data that it hasnt seen.\n\nWe have 10 years of historical data. we will use the first 9 to train the model, and the 10th year to test it. Moreover, we will use 10 fold cross validation on the training data as well. So before we actually try out a variety of modelling algorithms, we need to partition the data into training and testing datasets.\n\n## Let's Partition The Data\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rattle)   \n```\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: tibble\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: bitops\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nRattle: A free graphical interface for data science with R.\nVersion 5.5.1 Copyright (c) 2006-2021 Togaware Pty Ltd.\nType 'rattle()' to shake, rattle, and roll your data.\n```\n:::\n\n```{.r .cell-code}\nlibrary(magrittr) # For the %>% and %<>% operators.\n\n\n\nbuilding <- TRUE\nscoring  <- ! building\n\n\n# A pre-defined value is used to reset the random seed so that results are repeatable.\n\ncrv$seed <- 42 \n\n\n# Load an R data frame.\nlibrary(readr)\nMFG10YearTerminationData <- read_csv(\"MFG10YearTerminationData.csv\", \n    col_types = cols(gender_full = col_factor(levels = c(\"Male\", \n        \"Female\")), STATUS = col_factor(levels = c(\"ACTIVE\", \n        \"TERMINATED\")), BUSINESS_UNIT = col_factor(levels = c(\"HEADOFFICE\", \n        \"STORES\"))))\n\nMYdataset <- MFG10YearTerminationData\n\n\n\n#Create training and testing datasets\n\n#Create training and testing datasets\n\nset.seed(crv$seed) \nMYnobs <- nrow(MYdataset) # 52692 observations \nMYsample <- MYtrain <- subset(MYdataset,STATUS_YEAR<=2014)\nMYvalidate <- NULL\nMYtest <- subset(MYdataset,STATUS_YEAR== 2015)\n\n# The following variable selections have been noted.\n\nMYinput <- c(\"age\", \"length_of_service\",    \"gender_full\",\n               \"STATUS_YEAR\", \"BUSINESS_UNIT\")\n\nMYnumeric <- c(\"age\", \"length_of_service\", \"STATUS_YEAR\")\n\nMYcategoric <- c(  \n                   \"gender_full\", \"BUSINESS_UNIT\")\n\nMYtarget  <- \"STATUS\"\nMYrisk    <- NULL\nMYident   <- \"EmployeeID\"\nMYignore  <- c(\"recorddate_key\", \"birthdate_key\", \"orighiredate_key\", \"terminationdate_key\", \"city_name\", \"gender_short\", \"termreason_desc\", \"termtype_desc\",\"department_name\",\n               \"job_title\", \"store_name\")\nMYweights <- NULL\n\nMYTrainingData<-MYtrain[c(MYinput, MYtarget)]\nMYTestingData<-MYtest[c(MYinput, MYtarget)]\n```\n:::\n\n\n## Choosing and Running Models\n\nOne of the things that characterizes R, is that the number of functions and procedures that can be used are huge. So there often many ways of doing things. Two of the best R packages designed to be used for data science are **caret** and **rattle**.\n\nWe introduced caret in the last blog article. In this one I will use **rattle**. **What is noteworthy about rattle is that it provides a GUI front end and generates the code for it in the log on the backend. So you can generate models quickly.**\n\nI **wont** be illustrating how to use rattle in this article as a GUI, but rather show the code it generated along with the statistical results and graphs. **Please dont get hung up/turned off by the code presented.** The GUI front end generated all the code below. I simply made cosmetic changes to it. **Please do concentrate on the flow of the data science process in the article as one example of how it can be done.**. As a GUI rattle was able to generate all the below output in about 15 minutes of my effort. One tutorial on the rattle GUI cam be found here:\n\n<http://eric.univ-lyon2.fr/~ricco/tanagra/fichiers/en_Tanagra_Rattle_Package_for_R.pdf>\n\nAnd here is a book on rattle:\n\n<http://www.amazon.com/gp/product/1441998896/ref=as_li_qf_sp_asin_tl?ie=UTF8&tag=togaware-20&linkCode=as2&camp=217145&creative=399373&creativeASIN=1441998896>\n\nWe should step back for a moment and review what are doing here, and what are opening questions were. We are wanting to predict who might terminate in the future. That is a 'binary result' or 'category'. A person is either 'ACTIVE' or 'TERMINATED'. \\_\\_Since it is a category to be predicted we will choose among models/algorithms that can predict categories.\\_\n\nThe models we will look at in rattle are:\n\n-   Decision Trees (rpart)\n-   Boosted Models (adaboost)\n-   Random Forests (rf)\n-   Support Vactor Models (svm)\n-   Linear Models (glm)\n\n### Decision Tree\n\nLets first u take a look at a decision tree model. This is always useful because with these, you can get a visual tree model to get some idea of how the prediction occurs in an easy to understand way.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rattle)\nlibrary(rpart, quietly=TRUE)\n\n# Reset the random number seed to obtain the same results each time.\n\nset.seed(crv$seed)\n\n# Build the Decision Tree model.\n\nMYrpart <- rpart(STATUS ~ .,\n                   data=MYtrain[, c(MYinput, MYtarget)],\n                   method=\"class\",\n                   parms=list(split=\"information\"),\n                   control=rpart.control(usesurrogate=0, \n                                         maxsurrogate=0))\n\n# Generate a textual view of the Decision Tree model.\n\n#print(MYrpart)\n#printcp(MYrpart)\n#cat(\"\\n\")\n\n# Time taken: 0.63 secs\n\n#============================================================\n# Rattle timestamp: 2016-03-25 09:45:25 x86_64-w64-mingw32 \n\n# Plot the resulting Decision Tree. \n\n# We use the rpart.plot package.\n\nfancyRpartPlot(MYrpart, main=\"Decision Tree MFG10YearTerminationData $ STATUS\")\n```\n\n::: {.cell-output-display}\n![](PAExampleChurn_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\nWe can now answer our next guestion from above:\n\n**What, if anything, else contributes to it?**\n\nFrom even the graphical tree output it looks like gender, and status year also affect it.\n\n### Random Forests\n\nNow for Random Forests\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#============================================================\n# Rattle timestamp: 2016-03-25 18:21:29 x86_64-w64-mingw32 \n\n# Random Forest \n\n# The 'randomForest' package provides the 'randomForest' function.\n\nlibrary(randomForest, quietly=TRUE)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nrandomForest 4.7-1.1\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nType rfNews() to see new features/changes/bug fixes.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'randomForest'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following object is masked from 'package:rattle':\n\n    importance\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following object is masked from 'package:ggplot2':\n\n    margin\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following object is masked from 'package:dplyr':\n\n    combine\n```\n:::\n\n```{.r .cell-code}\n# Build the Random Forest model.\n\nset.seed(crv$seed)\nMYrf <- randomForest::randomForest(STATUS ~ .,\n                                   data=MYtrain[c(MYinput, MYtarget)],\n                                   ntree=500,\n                                   mtry=2,\n                                   importance=TRUE,\n                                   na.action=randomForest::na.roughfix,\n                                   replace=FALSE)\n\n# Generate textual output of 'Random Forest' model.\n\nMYrf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\n randomForest(formula = STATUS ~ ., data = MYtrain[c(MYinput,      MYtarget)], ntree = 500, mtry = 2, importance = TRUE, replace = FALSE,      na.action = randomForest::na.roughfix) \n               Type of random forest: classification\n                     Number of trees: 500\nNo. of variables tried at each split: 2\n\n        OOB estimate of  error rate: 1.13%\nConfusion matrix:\n           ACTIVE TERMINATED  class.error\nACTIVE      43366          3 6.917383e-05\nTERMINATED    501        822 3.786848e-01\n```\n:::\n\n```{.r .cell-code}\n# The `pROC' package implements various AUC functions.\n\n# Calculate the Area Under the Curve (AUC).\n\npROC::roc(MYrf$y, as.numeric(MYrf$predicted))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nSetting levels: control = ACTIVE, case = TERMINATED\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nSetting direction: controls < cases\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nroc.default(response = MYrf$y, predictor = as.numeric(MYrf$predicted))\n\nData: as.numeric(MYrf$predicted) in 43369 controls (MYrf$y ACTIVE) < 1323 cases (MYrf$y TERMINATED).\nArea under the curve: 0.8106\n```\n:::\n\n```{.r .cell-code}\n# Calculate the AUC Confidence Interval.\n\npROC::ci.auc(MYrf$y, as.numeric(MYrf$predicted))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nSetting levels: control = ACTIVE, case = TERMINATED\nSetting direction: controls < cases\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n95% CI: 0.7975-0.8237 (DeLong)\n```\n:::\n\n```{.r .cell-code}\n# List the importance of the variables.\n\nrn <- round(randomForest::importance(MYrf), 2)\nrn[order(rn[,3], decreasing=TRUE),]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                  ACTIVE TERMINATED MeanDecreaseAccuracy MeanDecreaseGini\nage                36.57     156.31                53.12           744.59\ngender_full        27.22      39.05                35.50            76.76\nSTATUS_YEAR        29.99      32.35                34.69            61.70\nlength_of_service  17.68      17.75                20.94            95.03\nBUSINESS_UNIT       5.48       7.43                 7.28             3.72\n```\n:::\n\n```{.r .cell-code}\n# Time taken: 18.66 secs\n```\n:::\n\n\n### Adaboost\n\nNow for adaboost\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#============================================================\n# Rattle timestamp: 2016-03-25 18:22:22 x86_64-w64-mingw32 \n\n# Ada Boost \n\n# The `ada' package implements the boost algorithm.\n\n# Build the Ada Boost model.\n\nset.seed(crv$seed)\nMYada <- ada::ada(STATUS ~ .,\n                  data=MYtrain[c(MYinput, MYtarget)],\n                  control=rpart::rpart.control(maxdepth=30,\n                                               cp=0.010000,\n                                               minsplit=20,\n                                               xval=10),\n                  iter=50)\n\n# Print the results of the modelling.\n\nprint(MYada)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCall:\nada(STATUS ~ ., data = MYtrain[c(MYinput, MYtarget)], control = rpart::rpart.control(maxdepth = 30, \n    cp = 0.01, minsplit = 20, xval = 10), iter = 50)\n\nLoss: exponential Method: discrete   Iteration: 50 \n\nFinal Confusion Matrix for Data:\n            Final Prediction\nTrue value   ACTIVE TERMINATED\n  ACTIVE      43366          3\n  TERMINATED    501        822\n\nTrain Error: 0.011 \n\nOut-Of-Bag Error:  0.011  iteration= 6 \n\nAdditional Estimates of number of iterations:\n\ntrain.err1 train.kap1 \n         1          1 \n```\n:::\n\n```{.r .cell-code}\nround(MYada$model$errs[MYada$iter,], 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntrain.err train.kap \n     0.01      0.24 \n```\n:::\n\n```{.r .cell-code}\ncat('Variables actually used in tree construction:\\n')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nVariables actually used in tree construction:\n```\n:::\n\n```{.r .cell-code}\nprint(sort(names(listAdaVarsUsed(MYada))))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"age\"               \"gender_full\"       \"length_of_service\"\n[4] \"STATUS_YEAR\"      \n```\n:::\n\n```{.r .cell-code}\ncat('\\nFrequency of variables actually used:\\n')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nFrequency of variables actually used:\n```\n:::\n\n```{.r .cell-code}\nprint(listAdaVarsUsed(MYada))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n              age       STATUS_YEAR length_of_service       gender_full \n               45                40                39                25 \n```\n:::\n:::\n\n\n### Support Vector Machines\n\nNow lets look at Support Vector Machines\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#============================================================\n# Rattle timestamp: 2016-03-25 18:22:56 x86_64-w64-mingw32 \n\n# Support vector machine. \n\n# The 'kernlab' package provides the 'ksvm' function.\n\nlibrary(kernlab, quietly=TRUE)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'kernlab'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following object is masked from 'package:ggplot2':\n\n    alpha\n```\n:::\n\n```{.r .cell-code}\n# Build a Support Vector Machine model.\n\nset.seed(crv$seed)\nMYksvm <- ksvm(as.factor(STATUS) ~ .,\n               data=MYtrain[c(MYinput, MYtarget)],\n               kernel=\"rbfdot\",\n               prob.model=TRUE)\n\n# Generate a textual view of the SVM model.\n\nMYksvm\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSupport Vector Machine object of class \"ksvm\" \n\nSV type: C-svc  (classification) \n parameter : cost C = 1 \n\nGaussian Radial Basis kernel function. \n Hyperparameter : sigma =  0.370016942069632 \n\nNumber of Support Vectors : 2425 \n\nObjective Function Value : -1999.052 \nTraining error : 0.017811 \nProbability model included. \n```\n:::\n\n```{.r .cell-code}\n# Time taken: 42.91 secs\n```\n:::\n\n\n### Linear Models\n\nFinally lets look at linear models.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#============================================================\n# Rattle timestamp: 2016-03-25 18:23:56 x86_64-w64-mingw32 \n\n# Regression model \n\n# Build a Regression model.\n\nMYglm <- glm(STATUS ~ .,\n             data=MYtrain[c(MYinput, MYtarget)],\n             family=binomial(link=\"logit\"))\n\n# Generate a textual view of the Linear model.\n\nprint(summary(MYglm))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nglm(formula = STATUS ~ ., family = binomial(link = \"logit\"), \n    data = MYtrain[c(MYinput, MYtarget)])\n\nDeviance Residuals: \n    Min       1Q   Median       3Q      Max  \n-1.3245  -0.2076  -0.1564  -0.1184   3.4080  \n\nCoefficients:\n                      Estimate Std. Error z value Pr(>|z|)    \n(Intercept)         -892.99983   33.95417 -26.300  < 2e-16 ***\nage                    0.21944    0.00438  50.095  < 2e-16 ***\nlength_of_service     -0.43146    0.01086 -39.738  < 2e-16 ***\ngender_fullFemale     -0.51900    0.06766  -7.671  1.7e-14 ***\nSTATUS_YEAR            0.44122    0.01687  26.148  < 2e-16 ***\nBUSINESS_UNITSTORES   -2.73943    0.16616 -16.486  < 2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n(Dispersion parameter for binomial family taken to be 1)\n\n    Null deviance: 11920.1  on 44691  degrees of freedom\nResidual deviance:  9053.3  on 44686  degrees of freedom\nAIC: 9065.3\n\nNumber of Fisher Scoring iterations: 7\n```\n:::\n\n```{.r .cell-code}\ncat(sprintf(\"Log likelihood: %.3f (%d df)\\n\",\n            logLik(MYglm)[1],\n            attr(logLik(MYglm), \"df\")))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nLog likelihood: -4526.633 (6 df)\n```\n:::\n\n```{.r .cell-code}\ncat(sprintf(\"Null/Residual deviance difference: %.3f (%d df)\\n\",\n            MYglm$null.deviance-MYglm$deviance,\n            MYglm$df.null-MYglm$df.residual))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNull/Residual deviance difference: 2866.813 (5 df)\n```\n:::\n\n```{.r .cell-code}\ncat(sprintf(\"Chi-square p-value: %.8f\\n\",\n            dchisq(MYglm$null.deviance-MYglm$deviance,\n                   MYglm$df.null-MYglm$df.residual)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nChi-square p-value: 0.00000000\n```\n:::\n\n```{.r .cell-code}\ncat(sprintf(\"Pseudo R-Square (optimistic): %.8f\\n\",\n            cor(MYglm$y, MYglm$fitted.values)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPseudo R-Square (optimistic): 0.38428451\n```\n:::\n\n```{.r .cell-code}\ncat('\\n==== ANOVA ====\\n\\n')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n==== ANOVA ====\n```\n:::\n\n```{.r .cell-code}\nprint(anova(MYglm, test=\"Chisq\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAnalysis of Deviance Table\n\nModel: binomial, link: logit\n\nResponse: STATUS\n\nTerms added sequentially (first to last)\n\n                  Df Deviance Resid. Df Resid. Dev  Pr(>Chi)    \nNULL                              44691    11920.1              \nage                1   861.75     44690    11058.3 < 2.2e-16 ***\nlength_of_service  1  1094.72     44689     9963.6 < 2.2e-16 ***\ngender_full        1    14.38     44688     9949.2 0.0001494 ***\nSTATUS_YEAR        1   716.39     44687     9232.8 < 2.2e-16 ***\nBUSINESS_UNIT      1   179.57     44686     9053.3 < 2.2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n:::\n\n```{.r .cell-code}\ncat(\"\\n\")\n```\n\n```{.r .cell-code}\n# Time taken: 1.62 secs\n```\n:::\n\n\nThese were simply the vanilla running of these models.In evaluating the models we have the means to compare their results on a common basis.\n\n## Evaluate Models\n\nIn the evaluating models step, we are able to answer our final 2 original questions stated at the beginning:\n\n**Can we predict?**\n\nIn a word 'yes'.\n\n**How Well can we predict?**\n\nIn two words 'fairly well'.\n\nWhen it comes to evaluating models for predicting categories, we are defining accuracy as to how many times did the model predict the actual. So we are interested in a number of things.\n\nThe first of these are error martricies. In error matricies, you are cross tabulating the actual results with predicted results. If prediction was 'perfect' 100%, every prediction would be the same as actual. (almost never happens). The higher the correct prediction rate and lower the error rate- the better.\n\n### Error Matricies\n\n#### Decision Trees\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#============================================================\n# Rattle timestamp: 2016-03-25 18:50:22 x86_64-w64-mingw32 \n\n# Evaluate model performance. \n\n# Generate an Error Matrix for the Decision Tree model.\n\n# Obtain the response from the Decision Tree model.\n\nMYpr <- predict(MYrpart, newdata=MYtest[c(MYinput, MYtarget)], type=\"class\")\n\n# Generate the confusion matrix showing counts.\n\ntable(MYtest[c(MYinput, MYtarget)]$STATUS, MYpr,\n      dnn=c(\"Actual\", \"Predicted\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n            Predicted\nActual       ACTIVE TERMINATED\n  ACTIVE       4799          0\n  TERMINATED     99         63\n```\n:::\n\n```{.r .cell-code}\n# Generate the confusion matrix showing proportions.\n\npcme <- function(actual, cl)\n{\n  x <- table(actual, cl)\n  nc <- nrow(x)\n  tbl <- cbind(x/length(actual),\n               Error=sapply(1:nc,\n                            function(r) round(sum(x[r,-r])/sum(x[r,]), 2)))\n  names(attr(tbl, \"dimnames\")) <- c(\"Actual\", \"Predicted\")\n  return(tbl)\n}\nper <- pcme(MYtest[c(MYinput, MYtarget)]$STATUS, MYpr)\nround(per, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n            Predicted\nActual       ACTIVE TERMINATED Error\n  ACTIVE       0.97       0.00  0.00\n  TERMINATED   0.02       0.01  0.61\n```\n:::\n\n```{.r .cell-code}\n# Calculate the overall error percentage.\n\ncat(100*round(1-sum(diag(per), na.rm=TRUE), 2))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2\n```\n:::\n\n```{.r .cell-code}\n# Calculate the averaged class error percentage.\n\ncat(100*round(mean(per[,\"Error\"], na.rm=TRUE), 2))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n30\n```\n:::\n:::\n\n\n#### Adaboost\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Generate an Error Matrix for the Ada Boost model.\n\n# Obtain the response from the Ada Boost model.\n\nMYpr <- predict(MYada, newdata=MYtest[c(MYinput, MYtarget)])\n\n# Generate the confusion matrix showing counts.\n\ntable(MYtest[c(MYinput, MYtarget)]$STATUS, MYpr,\n      dnn=c(\"Actual\", \"Predicted\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n            Predicted\nActual       ACTIVE TERMINATED\n  ACTIVE       4799          0\n  TERMINATED     99         63\n```\n:::\n\n```{.r .cell-code}\n# Generate the confusion matrix showing proportions.\n\npcme <- function(actual, cl)\n{\n  x <- table(actual, cl)\n  nc <- nrow(x)\n  tbl <- cbind(x/length(actual),\n               Error=sapply(1:nc,\n                            function(r) round(sum(x[r,-r])/sum(x[r,]), 2)))\n  names(attr(tbl, \"dimnames\")) <- c(\"Actual\", \"Predicted\")\n  return(tbl)\n}\nper <- pcme(MYtest[c(MYinput, MYtarget)]$STATUS, MYpr)\nround(per, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n            Predicted\nActual       ACTIVE TERMINATED Error\n  ACTIVE       0.97       0.00  0.00\n  TERMINATED   0.02       0.01  0.61\n```\n:::\n\n```{.r .cell-code}\n# Calculate the overall error percentage.\n\ncat(100*round(1-sum(diag(per), na.rm=TRUE), 2))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2\n```\n:::\n\n```{.r .cell-code}\n# Calculate the averaged class error percentage.\n\ncat(100*round(mean(per[,\"Error\"], na.rm=TRUE), 2))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n30\n```\n:::\n:::\n\n\n#### Random Forest\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Generate an Error Matrix for the Random Forest model.\n\n# Obtain the response from the Random Forest model.\n\nMYpr <- predict(MYrf, newdata=na.omit(MYtest[c(MYinput, MYtarget)]))\n\n# Generate the confusion matrix showing counts.\n\ntable(na.omit(MYtest[c(MYinput, MYtarget)])$STATUS, MYpr,\n      dnn=c(\"Actual\", \"Predicted\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n            Predicted\nActual       ACTIVE TERMINATED\n  ACTIVE       4799          0\n  TERMINATED     99         63\n```\n:::\n\n```{.r .cell-code}\n# Generate the confusion matrix showing proportions.\n\npcme <- function(actual, cl)\n{\n  x <- table(actual, cl)\n  nc <- nrow(x)\n  tbl <- cbind(x/length(actual),\n               Error=sapply(1:nc,\n                            function(r) round(sum(x[r,-r])/sum(x[r,]), 2)))\n  names(attr(tbl, \"dimnames\")) <- c(\"Actual\", \"Predicted\")\n  return(tbl)\n}\nper <- pcme(na.omit(MYtest[c(MYinput, MYtarget)])$STATUS, MYpr)\nround(per, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n            Predicted\nActual       ACTIVE TERMINATED Error\n  ACTIVE       0.97       0.00  0.00\n  TERMINATED   0.02       0.01  0.61\n```\n:::\n\n```{.r .cell-code}\n# Calculate the overall error percentage.\n\ncat(100*round(1-sum(diag(per), na.rm=TRUE), 2))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2\n```\n:::\n\n```{.r .cell-code}\n# Calculate the averaged class error percentage.\n\ncat(100*round(mean(per[,\"Error\"], na.rm=TRUE), 2))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n30\n```\n:::\n:::\n\n\n#### Support Vector Model\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Generate an Error Matrix for the SVM model.\n\n# Obtain the response from the SVM model.\n\nMYpr <- kernlab::predict(MYksvm, newdata=na.omit(MYtest[c(MYinput, MYtarget)]))\n\n# Generate the confusion matrix showing counts.\n\ntable(na.omit(MYtest[c(MYinput, MYtarget)])$STATUS, MYpr,\n      dnn=c(\"Actual\", \"Predicted\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n            Predicted\nActual       ACTIVE TERMINATED\n  ACTIVE       4799          0\n  TERMINATED    150         12\n```\n:::\n\n```{.r .cell-code}\n# Generate the confusion matrix showing proportions.\n\npcme <- function(actual, cl)\n{\n  x <- table(actual, cl)\n  nc <- nrow(x)\n  tbl <- cbind(x/length(actual),\n               Error=sapply(1:nc,\n                            function(r) round(sum(x[r,-r])/sum(x[r,]), 2)))\n  names(attr(tbl, \"dimnames\")) <- c(\"Actual\", \"Predicted\")\n  return(tbl)\n}\nper <- pcme(na.omit(MYtest[c(MYinput, MYtarget)])$STATUS, MYpr)\nround(per, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n            Predicted\nActual       ACTIVE TERMINATED Error\n  ACTIVE       0.97          0  0.00\n  TERMINATED   0.03          0  0.93\n```\n:::\n\n```{.r .cell-code}\n# Calculate the overall error percentage.\n\ncat(100*round(1-sum(diag(per), na.rm=TRUE), 2))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n3\n```\n:::\n\n```{.r .cell-code}\n# Calculate the averaged class error percentage.\n\ncat(100*round(mean(per[,\"Error\"], na.rm=TRUE), 2))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n47\n```\n:::\n:::\n\n\n#### Linear Model\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Generate an Error Matrix for the Linear model.\n\n# Obtain the response from the Linear model.\n\nMYpr <- as.vector(ifelse(predict(MYglm, type=\"response\", newdata=MYtest[c(MYinput, MYtarget)]) > 0.5, \"TERMINATED\", \"ACTIVE\"))\n\n# Generate the confusion matrix showing counts.\n\ntable(MYtest[c(MYinput, MYtarget)]$STATUS, MYpr,\n      dnn=c(\"Actual\", \"Predicted\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n            Predicted\nActual       ACTIVE\n  ACTIVE       4799\n  TERMINATED    162\n```\n:::\n\n```{.r .cell-code}\n# Generate the confusion matrix showing proportions.\n\npcme <- function(actual, cl)\n{\n  x <- table(actual, cl)\n  nc <- nrow(x)\n  tbl <- cbind(x/length(actual),\n               Error=sapply(1:nc,\n                            function(r) round(sum(x[r,-r])/sum(x[r,]), 2)))\n  names(attr(tbl, \"dimnames\")) <- c(\"Actual\", \"Predicted\")\n  return(tbl)\n}\nper <- pcme(MYtest[c(MYinput, MYtarget)]$STATUS, MYpr)\nround(per, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n            Predicted\nActual       ACTIVE Error\n  ACTIVE       0.97     0\n  TERMINATED   0.03     1\n```\n:::\n\n```{.r .cell-code}\n# Calculate the overall error percentage.\n\ncat(100*round(1-sum(diag(per), na.rm=TRUE), 2))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n-97\n```\n:::\n\n```{.r .cell-code}\n# Calculate the averaged class error percentage.\n\ncat(100*round(mean(per[,\"Error\"], na.rm=TRUE), 2))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n50\n```\n:::\n:::\n\n\n**Well that was interesting!**\n\nSummarizing the confusion matrix showed that decision trees,random forests, and adaboost all predicted similarly. **BUT** Support Vector Machines and the Linear Models did worse for this data.\n\n###Area Under Curve (AUC)\n\nAnother way to evaluate the models is the AUC. The higher the AUC the better. The code below generates the information necessary to produce the graphs.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#============================================================\n# Rattle timestamp: 2016-03-25 19:44:22 x86_64-w64-mingw32 \n\n# Evaluate model performance. \n\n# ROC Curve: requires the ROCR package.\n\nlibrary(ROCR)\n\n# ROC Curve: requires the ggplot2 package.\n\nlibrary(ggplot2, quietly=TRUE)\n\n# Generate an ROC Curve for the rpart model on MFG10YearTerminationData [test].\n\nMYpr <- predict(MYrpart, newdata=MYtest[c(MYinput, MYtarget)])[,2]\n\n# Remove observations with missing target.\n\nno.miss   <- na.omit(MYtest[c(MYinput, MYtarget)]$STATUS)\nmiss.list <- attr(no.miss, \"na.action\")\nattributes(no.miss) <- NULL\n\nif (length(miss.list))\n{\n  pred <- prediction(MYpr[-miss.list], no.miss)\n} else\n{\n  pred <- prediction(MYpr, no.miss)\n}\n\npe <- performance(pred, \"tpr\", \"fpr\")\nau <- performance(pred, \"auc\")@y.values[[1]]\npd <- data.frame(fpr=unlist(pe@x.values), tpr=unlist(pe@y.values))\np <- ggplot(pd, aes(x=fpr, y=tpr))\np <- p + geom_line(colour=\"red\")\np <- p + xlab(\"False Positive Rate\") + ylab(\"True Positive Rate\")\np <- p + ggtitle(\"ROC Curve Decision Tree MFG10YearTerminationData [test] STATUS\")\np <- p + theme(plot.title=element_text(size=10))\np <- p + geom_line(data=data.frame(), aes(x=c(0,1), y=c(0,1)), colour=\"grey\")\np <- p + annotate(\"text\", x=0.50, y=0.00, hjust=0, vjust=0, size=5,\n                  label=paste(\"AUC =\", round(au, 2)))\nprint(p)\n```\n\n::: {.cell-output-display}\n![](PAExampleChurn_files/figure-html/unnamed-chunk-21-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# Calculate the area under the curve for the plot.\n\n\n# Remove observations with missing target.\n\nno.miss   <- na.omit(MYtest[c(MYinput, MYtarget)]$STATUS)\nmiss.list <- attr(no.miss, \"na.action\")\nattributes(no.miss) <- NULL\n\nif (length(miss.list))\n{\n  pred <- prediction(MYpr[-miss.list], no.miss)\n} else\n{\n  pred <- prediction(MYpr, no.miss)\n}\nperformance(pred, \"auc\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nA performance instance\n  'Area under the ROC curve'\n```\n:::\n\n```{.r .cell-code}\n# ROC Curve: requires the ROCR package.\n\nlibrary(ROCR)\n\n# ROC Curve: requires the ggplot2 package.\n\nlibrary(ggplot2, quietly=TRUE)\n\n# Generate an ROC Curve for the ada model on MFG10YearTerminationData [test].\n\nMYpr <- predict(MYada, newdata=MYtest[c(MYinput, MYtarget)], type=\"prob\")[,2]\n\n# Remove observations with missing target.\n\nno.miss   <- na.omit(MYtest[c(MYinput, MYtarget)]$STATUS)\nmiss.list <- attr(no.miss, \"na.action\")\nattributes(no.miss) <- NULL\n\nif (length(miss.list))\n{\n  pred <- prediction(MYpr[-miss.list], no.miss)\n} else\n{\n  pred <- prediction(MYpr, no.miss)\n}\n\npe <- performance(pred, \"tpr\", \"fpr\")\nau <- performance(pred, \"auc\")@y.values[[1]]\npd <- data.frame(fpr=unlist(pe@x.values), tpr=unlist(pe@y.values))\np <- ggplot(pd, aes(x=fpr, y=tpr))\np <- p + geom_line(colour=\"red\")\np <- p + xlab(\"False Positive Rate\") + ylab(\"True Positive Rate\")\np <- p + ggtitle(\"ROC Curve Ada Boost MFG10YearTerminationData [test] STATUS\")\np <- p + theme(plot.title=element_text(size=10))\np <- p + geom_line(data=data.frame(), aes(x=c(0,1), y=c(0,1)), colour=\"grey\")\np <- p + annotate(\"text\", x=0.50, y=0.00, hjust=0, vjust=0, size=5,\n                  label=paste(\"AUC =\", round(au, 2)))\nprint(p)\n```\n\n::: {.cell-output-display}\n![](PAExampleChurn_files/figure-html/unnamed-chunk-21-2.png){width=672}\n:::\n\n```{.r .cell-code}\n# Calculate the area under the curve for the plot.\n\n\n# Remove observations with missing target.\n\nno.miss   <- na.omit(MYtest[c(MYinput, MYtarget)]$STATUS)\nmiss.list <- attr(no.miss, \"na.action\")\nattributes(no.miss) <- NULL\n\nif (length(miss.list))\n{\n  pred <- prediction(MYpr[-miss.list], no.miss)\n} else\n{\n  pred <- prediction(MYpr, no.miss)\n}\nperformance(pred, \"auc\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nA performance instance\n  'Area under the ROC curve'\n```\n:::\n\n```{.r .cell-code}\n# ROC Curve: requires the ROCR package.\n\nlibrary(ROCR)\n\n# ROC Curve: requires the ggplot2 package.\n\nlibrary(ggplot2, quietly=TRUE)\n\n# Generate an ROC Curve for the rf model on MFG10YearTerminationData [test].\n\nMYpr <- predict(MYrf, newdata=na.omit(MYtest[c(MYinput, MYtarget)]), type=\"prob\")[,2]\n\n# Remove observations with missing target.\n\nno.miss   <- na.omit(na.omit(MYtest[c(MYinput, MYtarget)])$STATUS)\nmiss.list <- attr(no.miss, \"na.action\")\nattributes(no.miss) <- NULL\n\nif (length(miss.list))\n{\n  pred <- prediction(MYpr[-miss.list], no.miss)\n} else\n{\n  pred <- prediction(MYpr, no.miss)\n}\n\npe <- performance(pred, \"tpr\", \"fpr\")\nau <- performance(pred, \"auc\")@y.values[[1]]\npd <- data.frame(fpr=unlist(pe@x.values), tpr=unlist(pe@y.values))\np <- ggplot(pd, aes(x=fpr, y=tpr))\np <- p + geom_line(colour=\"red\")\np <- p + xlab(\"False Positive Rate\") + ylab(\"True Positive Rate\")\np <- p + ggtitle(\"ROC Curve Random Forest MFG10YearTerminationData [test] STATUS\")\np <- p + theme(plot.title=element_text(size=10))\np <- p + geom_line(data=data.frame(), aes(x=c(0,1), y=c(0,1)), colour=\"grey\")\np <- p + annotate(\"text\", x=0.50, y=0.00, hjust=0, vjust=0, size=5,\n                  label=paste(\"AUC =\", round(au, 2)))\nprint(p)\n```\n\n::: {.cell-output-display}\n![](PAExampleChurn_files/figure-html/unnamed-chunk-21-3.png){width=672}\n:::\n\n```{.r .cell-code}\n# Calculate the area under the curve for the plot.\n\n\n# Remove observations with missing target.\n\nno.miss   <- na.omit(na.omit(MYtest[c(MYinput, MYtarget)])$STATUS)\nmiss.list <- attr(no.miss, \"na.action\")\nattributes(no.miss) <- NULL\n\nif (length(miss.list))\n{\n  pred <- prediction(MYpr[-miss.list], no.miss)\n} else\n{\n  pred <- prediction(MYpr, no.miss)\n}\nperformance(pred, \"auc\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nA performance instance\n  'Area under the ROC curve'\n```\n:::\n\n```{.r .cell-code}\n# ROC Curve: requires the ROCR package.\n\nlibrary(ROCR)\n\n# ROC Curve: requires the ggplot2 package.\n\nlibrary(ggplot2, quietly=TRUE)\n\n# Generate an ROC Curve for the ksvm model on MFG10YearTerminationData [test].\n\nMYpr <- kernlab::predict(MYksvm, newdata=na.omit(MYtest[c(MYinput, MYtarget)]), type=\"probabilities\")[,2]\n\n# Remove observations with missing target.\n\nno.miss   <- na.omit(na.omit(MYtest[c(MYinput, MYtarget)])$STATUS)\nmiss.list <- attr(no.miss, \"na.action\")\nattributes(no.miss) <- NULL\n\nif (length(miss.list))\n{\n  pred <- prediction(MYpr[-miss.list], no.miss)\n} else\n{\n  pred <- prediction(MYpr, no.miss)\n}\n\npe <- performance(pred, \"tpr\", \"fpr\")\nau <- performance(pred, \"auc\")@y.values[[1]]\npd <- data.frame(fpr=unlist(pe@x.values), tpr=unlist(pe@y.values))\np <- ggplot(pd, aes(x=fpr, y=tpr))\np <- p + geom_line(colour=\"red\")\np <- p + xlab(\"False Positive Rate\") + ylab(\"True Positive Rate\")\np <- p + ggtitle(\"ROC Curve SVM MFG10YearTerminationData [test] STATUS\")\np <- p + theme(plot.title=element_text(size=10))\np <- p + geom_line(data=data.frame(), aes(x=c(0,1), y=c(0,1)), colour=\"grey\")\np <- p + annotate(\"text\", x=0.50, y=0.00, hjust=0, vjust=0, size=5,\n                  label=paste(\"AUC =\", round(au, 2)))\nprint(p)\n```\n\n::: {.cell-output-display}\n![](PAExampleChurn_files/figure-html/unnamed-chunk-21-4.png){width=672}\n:::\n\n```{.r .cell-code}\n# Calculate the area under the curve for the plot.\n\n\n# Remove observations with missing target.\n\nno.miss   <- na.omit(na.omit(MYtest[c(MYinput, MYtarget)])$STATUS)\nmiss.list <- attr(no.miss, \"na.action\")\nattributes(no.miss) <- NULL\n\nif (length(miss.list))\n{\n  pred <- prediction(MYpr[-miss.list], no.miss)\n} else\n{\n  pred <- prediction(MYpr, no.miss)\n}\nperformance(pred, \"auc\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nA performance instance\n  'Area under the ROC curve'\n```\n:::\n\n```{.r .cell-code}\n# ROC Curve: requires the ROCR package.\n\nlibrary(ROCR)\n\n# ROC Curve: requires the ggplot2 package.\n\nlibrary(ggplot2, quietly=TRUE)\n\n# Generate an ROC Curve for the glm model on MFG10YearTerminationData [test].\n\nMYpr <- predict(MYglm, type=\"response\", newdata=MYtest[c(MYinput, MYtarget)])\n\n# Remove observations with missing target.\n\nno.miss   <- na.omit(MYtest[c(MYinput, MYtarget)]$STATUS)\nmiss.list <- attr(no.miss, \"na.action\")\nattributes(no.miss) <- NULL\n\nif (length(miss.list))\n{\n  pred <- prediction(MYpr[-miss.list], no.miss)\n} else\n{\n  pred <- prediction(MYpr, no.miss)\n}\n\npe <- performance(pred, \"tpr\", \"fpr\")\nau <- performance(pred, \"auc\")@y.values[[1]]\npd <- data.frame(fpr=unlist(pe@x.values), tpr=unlist(pe@y.values))\np <- ggplot(pd, aes(x=fpr, y=tpr))\np <- p + geom_line(colour=\"red\")\np <- p + xlab(\"False Positive Rate\") + ylab(\"True Positive Rate\")\np <- p + ggtitle(\"ROC Curve Linear MFG10YearTerminationData [test] STATUS\")\np <- p + theme(plot.title=element_text(size=10))\np <- p + geom_line(data=data.frame(), aes(x=c(0,1), y=c(0,1)), colour=\"grey\")\np <- p + annotate(\"text\", x=0.50, y=0.00, hjust=0, vjust=0, size=5,\n                  label=paste(\"AUC =\", round(au, 2)))\nprint(p)\n```\n\n::: {.cell-output-display}\n![](PAExampleChurn_files/figure-html/unnamed-chunk-21-5.png){width=672}\n:::\n\n```{.r .cell-code}\n# Calculate the area under the curve for the plot.\n\n\n# Remove observations with missing target.\n\nno.miss   <- na.omit(MYtest[c(MYinput, MYtarget)]$STATUS)\nmiss.list <- attr(no.miss, \"na.action\")\nattributes(no.miss) <- NULL\n\nif (length(miss.list))\n{\n  pred <- prediction(MYpr[-miss.list], no.miss)\n} else\n{\n  pred <- prediction(MYpr, no.miss)\n}\nperformance(pred, \"auc\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nA performance instance\n  'Area under the ROC curve'\n```\n:::\n:::\n\n\nA couple of things to notice:\n\n-   **It turns out that the adaboost model produces the highest AUC.** So we will use it to predict the 2016 terminates in just a little bit.\n-   The Linear model was worst.\n\n# Present Results and Document\n\nAll the files (code, csv data file, and published formats) for this blog article can be found at the following link:\n\n<https://onedrive.live.com/redir?resid=4EF2CCBEDB98D0F5!6372&authkey=!ANDjbK5SkuAboc4&ithint=folder%2c>\n\nSimilar to the last blog article, the results are presented using the R Markdown language. The blog artile is written in it. It is the **rmd** file provided in the link. R Markdown allows inline integration of R code,results, and graphs with the textual material of this blor article. And it can be published in Word, HTML, or PDF formats.\n\nIf you want to run any of the code for this article you need to download the CSV files and make changes to the path information in the R code to suit where you located the CSV file.\n\n# Deploy Model\n\nLets predict the 2016 Terminates.\n\nIn real life you would take a snapshot of data at end of 2015 fof active employees. For purposes of this exercise we will do that but also alter the data to make both age year of service information - 1 year greater for 2016.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Apply model\n#Generate 2016 data\nEmployees2016<-MYtest #2015 data\n\nActiveEmployees2016<-subset(Employees2016,STATUS=='ACTIVE')\nActiveEmployees2016$age<-ActiveEmployees2016$age+1\nActiveEmployees2016$length_of_service<-ActiveEmployees2016$length_of_service+1\n\n#Predict 2016 Terminates using adaboost\n#MYada was name we gave to adaboost model earlier\nActiveEmployees2016$PredictedSTATUS2016<-predict(MYada,ActiveEmployees2016)\nPredictedTerminatedEmployees2016<-subset(ActiveEmployees2016,PredictedSTATUS2016=='TERMINATED')\n#show records for first 5 predictions\nhead(PredictedTerminatedEmployees2016)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 19\n  Emplo…¹ recor…² birthdat…³ orighire…⁴ terminat…⁵   age lengt…⁶ city_…⁷ depar…⁸\n    <dbl> <chr>   <date>     <date>     <date>     <dbl>   <dbl> <chr>   <chr>  \n1    1703 12/31/… 1951-01-13 1990-09-23 1900-01-01    65      26 Vancou… Meats  \n2    1705 12/31/… 1951-01-15 1990-09-24 1900-01-01    65      26 Richmo… Meats  \n3    1706 12/31/… 1951-01-20 1990-09-27 1900-01-01    65      26 Kelowna Meats  \n4    1710 12/31/… 1951-01-24 1990-09-29 1900-01-01    65      26 Prince… Custom…\n5    1713 12/31/… 1951-01-27 1990-10-01 1900-01-01    65      26 Vancou… Produce\n6    1715 12/31/… 1951-01-31 1990-10-03 1900-01-01    65      26 Richmo… Produce\n# … with 10 more variables: job_title <chr>, store_name <chr>,\n#   gender_short <chr>, gender_full <fct>, termreason_desc <chr>,\n#   termtype_desc <chr>, STATUS_YEAR <dbl>, STATUS <fct>, BUSINESS_UNIT <fct>,\n#   PredictedSTATUS2016 <fct>, and abbreviated variable names ¹​EmployeeID,\n#   ²​recorddate_key, ³​birthdate_key, ⁴​orighiredate_key, ⁵​terminationdate_key,\n#   ⁶​length_of_service, ⁷​city_name, ⁸​department_name\n```\n:::\n:::\n\n\nThere were 93 predicted terminates for 2016.\n\n#Wrap Up\n\nThe intent of this blog article was:\n\n-   to once again demonstrate a People Analytics example Using R\n-   to demonstrate a meaningful example from the HR context\n-   not to be necessarily a best practices example, rather an illustrative one\n-   to motivate the HR Community to make much more extensive use of 'data driven' HR decision making.\n-   to encourage those interested in using R in data science to delve more deeply into R's tools in this area.\n\nFrom a practical perpsective, if this was real data from a real organization, the onus would be on the organization to make 'decisions' about what the data is telling them.\n\nAgain enjoy the People Analytics journey...\n",
    "supporting": [
      "PAExampleChurn_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}