<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Lyndon Sundmark">
<meta name="dcterms.date" content="2015-03-25">

<title>HRAnalyticsBlogs - Data-Driven’ Job Classification Part 2</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">HRAnalyticsBlogs</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html" rel="" target="">
 <span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/" rel="" target=""><i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com" rel="" target=""><i class="bi bi-twitter" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Data-Driven’ Job Classification Part 2</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">HR Analytics</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Lyndon Sundmark </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">March 25, 2015</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        
    <div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="ddjobclasspt2.pdf"><i class="bi bi-file-pdf"></i>PDF</a></li><li><a href="ddjobclasspt2.docx"><i class="bi bi-file-word"></i>MS Word</a></li><li><a href="ddjobclasspt2.epub"><i class="bi bi-file"></i>ePub</a></li></ul></div></div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>In my last blog article, I showed an example of how ‘data driven’ analytical approaches could be applied to traditional HR methodologies, by looking at applying statistical discriminant analysis to a traditional non quantitative approach to job classification.</p>
<p>My intent in that article, this one, and a few more to come is to try to show HR in a series of small vignettes that ‘data driven’ is indeed possible for HR. It is applicable to:</p>
<ul>
<li><p>HR metrics reflecting people activity within our organizations</p></li>
<li><p>HR metrics reflecting HR operations</p></li>
<li><p>HR metrics reflecting deep embedding directly into our HR methodologies.</p></li>
</ul>
<p>The last article and this one are intended to show examples of the last bullet point. (I still intend to write some blog articles on the first two as well). But the third bullet point demanded at least one more blog article because there are so many methods in statistics that focus on ‘prediction’ of classifications and categories.</p>
<p>In addition to discriminant analysis in my last article, I mentioned that another method was ‘decision trees’. Still another is random forests. And there are still more beyond that. <strong>What I would like to do in this article is show examples of decision trees and random forests.</strong> As a continuation of the theme from the last blog article, I will first show these in the statistical package R.</p>
<p>However I will in this article also show these two methods in software packages that don’t require ‘programming in code’ in R, but rather show a couple of more ‘menu driven’ tools that are out there to do this. <strong>So the outline of the remainder of this blog article will be demonstration of data driven job classification through:</strong></p>
<ul>
<li><p>Decision trees in R</p></li>
<li><p>Random forests in R</p></li>
<li><p>Decision trees in a web based menu driven solution on the internet called BigML</p></li>
<li><p>Random forests in Microsoft Azure Machine Learning</p></li>
</ul>
<p>In demonstrating these, my intent again is NOT to provide a full manual or explanation or dissertation on the above. Each of the statistical methods and tools could be articles in and of themselves. <strong>The intent is to whet your appetite for ‘data driven’</strong>- so that you do further reading and research and study in this area and start applying these approaches to HR where your imagination takes you. I will only share as much detail as is necessary to get the ideas across.</p>
</section>
<section id="what-are-decision-trees-and-random-forests" class="level1">
<h1>What Are Decision Trees and Random Forests?</h1>
<p><strong>Decision trees and random forests are ‘data mining’ algorithms where the purpose of these algorithms or methods is ‘prediction’.</strong> Like discriminant analysis, we are trying to predict ‘something’. While decision trees can be used for both ‘regression’ purposes- predicting a continuous outcome, or classification purposes- a categorical outcome- the interest in this blog article is on the categorical outcome. We are interested in decision trees and random forests for ‘classification’- predicting a category. Let’s look into each of these in a little more detail.</p>
<section id="decision-trees" class="level2">
<h2 class="anchored" data-anchor-id="decision-trees">Decision Trees</h2>
<p><strong>Decision tree algorithms attempt to figure out a systematic set of ‘rules’ based on patterns it sees in the a data population which can then be used to relatively consistently correctly categorize items that are not yet in that data population.</strong> The decision tree looks like an upside down tree- where the top is a <strong>root node</strong>, and for which there are subsequent <strong>‘branch’ nodes</strong> that are further split by rules the algorithm has found in the data. And finally there are <strong>terminal nodes</strong>- points at which no further splits occur and a category has been predicted with a reasonable level of certainty. (There are books that define decision trees more formally – but I am trying to keep the description as simple as possible).</p>
<p><strong>In any case, each node in the decision tree is a question</strong>, for which there are ‘splits’ with respect to the answers- something either being equal to something or less than or greater than something. This then leads to another ‘question’ or ‘rule’ which in turn has splits for answers. By following the questions (rules) and answering them based on the features in the observation- we eventually get to a prediction of a category- based on the features and categories of the ‘known’ population.</p>
<p><strong>Similar to discriminant analysis- a ‘known’ population with ‘known’ categories and ‘known’ features is used as a base by the algorithms.</strong> When the analysis is done by the algorithm, the intent is to take new observations or records that are NOT in that original population and attempt to predict their category based on the features they evidence.</p>
<p><strong>AND- similar to discriminant analysis- ‘the proof is in the pudding’. We judge the usefulness of the ‘data mining’ tool based on how ‘well’ it predicts.</strong> I mentioned in the last blog article, that we can apply these algorithms on the original data ‘initially’ to see how well the model predicts what it already knows outside of itself- ( i.e.&nbsp;the training data). But in general, training data is often overly optimistic, and so we often hold out some ‘known’ data from the training data as ‘test’ data, to address ‘too optimistic’ prediction and over fitting of the data. Even though you are aware of this if you read my last article, I will use the training data later simply for illustration.</p>
<p>Clear so far?</p>
</section>
<section id="random-forests" class="level2">
<h2 class="anchored" data-anchor-id="random-forests">Random Forests</h2>
<p>Ok- so what are random forests as compared to decision trees and why do we need them?</p>
<p>According to Wikipedia:</p>
<p><a href="http://en.wikipedia.org/wiki/Random_forest" class="uri">http://en.wikipedia.org/wiki/Random_forest</a></p>
<p><strong>Random forests</strong> are an ensemble learning method for classification, regression and other tasks, that operate by constructing a multitude of decision trees at training time and outputting the class that is the mode of the classes (classification) or mean prediction (regression) of the individual trees. Random forests correct for decision trees’ habit of over fitting to their training set.</p>
<p>We had mentioned earlier, that ‘over fitting’ of decision trees can be an issue. What random forests are is a process of creating hundreds of individual trees at a time often using a ‘subset’ of the features for each tree constructed. The end result is still a prediction of a category. The difference is that you don’t have a single ‘tree’ you can look at and refer to and explain to someone else.</p>
<p>The bottom line for decision trees and random forests is that both of these attempt to predict a category of an item not in the existing population of known data, but based on what it sees as the ‘patterns’ in the data of the known population. And similar to discriminant analysis a confusion matrix (showing predicted versus actual- and proportions correct and incorrect) is a common denominator for comparison in usability in all of these tools- as we shall see in the examples below.</p>
<p>Hopefully the above gives a generally idea of the concepts and the purposes of these ‘data driven’ classification tools. The next sections will show examples of these in code using R, and then with more menu driven approaches.</p>
<p>Let’s see some examples of these with various tools.</p>
</section>
</section>
<section id="decision-trees-in-r" class="level1">
<h1>Decision Trees in R</h1>
<p>To invoke Decisions Trees in R requires the use of the library ‘rpart’. (rPart is one of many procedures in R that can generate decision trees)</p>
<p>Below you see the calling of that library with the word ‘require’.</p>
<p><img src="pic1.jpeg" class="img-fluid"></p>
<p>The code above in effect says take the paygrade (PG) as the dependent variable ( thing to be predicted) and run it against all the independent variables , for purposes of this tree. The variables of contact level, financial budget etc ( from previous blog article) are crs$input- which is the ’all other independent variables. I asked it to split even when there is one in a bucket or node. I won’t get into the details of the remainder of the parameters for purposes of this exercise because I am more interested in show the output. (Please note that parameters can be changed and will result in different outcomes each time you change them)</p>
<p>The decision tree generated looks something like this:</p>
<p>library(rpart.plot)prp(crs$rpart,main=“Decision Tree Jobclassinfo.xls $ PG”)</p>
<p><img src="pic2.jpeg" class="img-fluid"></p>
<p>The root node is ProblemSolving &lt;4.5. Each subsequent question is another node- and the terminal nodes are the ones that have the ‘PG’ categories where no further splits are occurring. These terminal nodes are the predictions based on the answers to the questions needed to get there. Note that the left split is always the ‘yes’ answer to the question and the right split is always the ‘no’ answer to the question.</p>
<p>Similar to linear discriminant analysis- you can prepare a confusion matrix to show the actual compared to the predicted:</p>
<p><img src="pic3.jpeg" class="img-fluid"></p>
<p><img src="pic4.jpeg" class="img-fluid"></p>
<p>The accuracy rate is even higher than the linear discriminant analysis in this example. Please note again this is on ‘training’ data- the model predicting itself which is likely to be overly optimistic and overfitted.</p>
<p>The neat thing about decision trees is that the rules that are formed are completely understandable to explain and follow- even without knowing the mathematical/statistical rigor that is behind it.</p>
</section>
<section id="random-forests-in-r" class="level1">
<h1>Random Forests in R</h1>
<p>As mentioned before, due to a single decision tree over fitting the data, random forests address this by creating hundreds of trees with various samplings from the population and average the results of the predictions from the trees. Because hundreds are generated, there is no way to meaningfully see the individual decision trees. However the summary results of the averaging can be seen in a confusion matrix:</p>
<p><img src="pic5.jpeg" class="img-fluid"></p>
<p><img src="pic6.jpeg" class="img-fluid">In this case the OOB estimate of the error rate is 52.17%- an estimate likely closer to an accuracy on ‘test’ data then ‘training’ data. This random forest used only 3 variables at a time to predict (ie ## No.&nbsp;of variables tried at each split: 3). The decision tree example previously used all the variables initially.</p>
<p>The point of showing both the decision tree and random forest examples above was to show that there are more ‘classification’ algorithms out there in statistics that can be used AND that R as a ‘programming language’ is rich in its features to help you accomplish that. The catch is that you must be prepared to learn both statistics and R to understand what you are doing to benefit from R’s richness.</p>
<p><strong>An immediate question you might ask is are the other ‘non-programming’ tools (tools that are more menu driven) that can be used to do some of this stuff?</strong> The quick answer to your question is ‘yes’. The caveat is that you still need to understand statistics, machine learning, statistical learning etc. at least at a basic level, to likely understand and know what you are doing.</p>
<p>Having said that, I would like to show a couple examples of menu driven (and in this case web based) tools that can be used for decision trees and random forests (and a whole lot more too). The first of these (for decision trees) is BigML. The second of these (for random forests) is Microsoft’s Azure Machine Learning</p>
</section>
<section id="bigml" class="level1">
<h1>BigML</h1>
<p>BigML can be found at:</p>
<p><a href="https://bigml.com/" class="uri">https://bigml.com/</a></p>
<p>BigML is a web based solution for predictive purposes. From what I have seen in experimenting with it, it makes extensive use of decision tree methodologies. So I decided to put my job classification data to it, to understand what it does and how it does it.</p>
<p>BigML requires you to:</p>
<p>Identify your data source Create your data set from the source Create a model Make predictions</p>
<section id="data-source" class="level2">
<h2 class="anchored" data-anchor-id="data-source">Data Source</h2>
<p>In this step you upload your data file to BigML.</p>
<p><img src="pic7.jpeg" class="img-fluid"></p>
<p>I have uploaded the CSV file</p>
</section>
<section id="dataset" class="level2">
<h2 class="anchored" data-anchor-id="dataset">Dataset</h2>
<p>Once the file is uploaded BigML can see its metadata and understand the fields. It assumes the last field is the thing you are trying to predict. In mine, the second field is what I am trying to predict so I tell it that. Notice I have the 7 predictor fields- education level through to financial budget.</p>
<p><img src="pic8.jpeg" class="img-fluid"></p>
</section>
<section id="model" class="level2">
<h2 class="anchored" data-anchor-id="model">Model</h2>
<p>The next step is to create the model. This is where you see the decision tree created. I have highlighted one of the paths:</p>
<p>It shows you the node rules to the right- for that path.</p>
</section>
<section id="predict" class="level2">
<h2 class="anchored" data-anchor-id="predict"><img src="pic9.jpeg" class="img-fluid">Predict</h2>
<p>The final step is to predict. It gives you a couple of options- but I will show just one:</p>
<p><img src="pic10.jpeg" class="img-fluid">At the top is the prediction. Below it are the settings for each of the predictors. What is supercool here is that you can vary the values on those predictors and the predicted category will change- in real time. Why is that cool? The predicted category only changes when the combination of values requires it to. One of the things I found for example was that the predictors can have a level of sensitivity/insensitivity. In other words problem solving could have a series of values that could be changed- for which there was no change in the predicted category (all other predictors held constant). This BigML web based graphical tool allows you to see that sensitivity- which might be difficult to do in other tools.</p>
<p>Finally with respect to the model- you can download a version of it to your computer in your favorite language. Examples include C#, VB Net, Excel and a number of others.</p>
<p>Other than taking a few minutes to familiarize myself with the BigML interface- once I did that it took me less than 10 minutes to have a working model that could predict- no code required.</p>
</section>
</section>
<section id="microsoft-azure-machine-learning" class="level1">
<h1>Microsoft Azure Machine Learning</h1>
<p>The final tool I want to show is a tool from Microsoft- in this case showing a random forest. Microsoft’s technology is also web based- like the previous tool. But Microsoft’s is also tied into Microsoft Azure. Why is this significant? There are probably many reasons- but the one I particularly paid attention to- was that after it has done its modelling- you can access that model in the cloud- from a variety of tools I think- but the one that was most direct and available was Excel. When you ‘publish’ your model- you can actually download a pre-created spreadsheet file that is fully linked up to and talks to the model you just created in the cloud. The significance of this is that if you give that spreadsheet to someone else- they too can use the same model and talk to it in the cloud to get the predictions based on data submitted on the spreadsheet.</p>
<p>Let’s take a quick look. It can be found at:</p>
<p><a href="https://studio.azureml.net/" class="uri">https://studio.azureml.net/</a></p>
<p><img src="pic11.jpeg" class="img-fluid">You create your model as an ‘experiment’:</p>
<ul>
<li><p>The model starts with uploading the csv file containing the data (jobclassinfoblog.csv).</p></li>
<li><p>The project columns step helps you tell this machine learning tool- what is to be predicted- and what the predictors are.</p></li>
<li><p>You choose what machine learning tool you want –in this case Multiclass Decision Forest.</p></li>
<li><p>You then tell it to train that tool on the datasource and dataset.</p></li>
<li><p>You then ask it to score the model.</p></li>
<li><p>Finally you evaluate its performance.</p></li>
</ul>
<p>Once you have actually executed the model- for each of the steps above- the grey dot at the ‘tail’ of each arrow- when ‘right-clicked’ allows you to visualize information at that step.</p>
<p><img src="pic13.jpeg" class="img-fluid">Here are examples of the visualize for the data and the results</p>
<section id="the-jobclass-data" class="level2">
<h2 class="anchored" data-anchor-id="the-jobclass-data">The Jobclass Data</h2>
</section>
<section id="the-evaluated-results" class="level2">
<h2 class="anchored" data-anchor-id="the-evaluated-results"><img src="pic14.jpeg" class="img-fluid">The Evaluated Results</h2>
<p><img src="pic15.jpeg" class="img-fluid"></p>
<p>When you are ready to publish your model ( make it visible to yourself and others as a usable outcome, the Azure Machine learning tool provides you with an Excel spreadsheet where you can put in your values:</p>
<p><img src="pic16.jpeg" class="img-fluid">It then shows you the predicted class:</p>
<p><img src="pic17.jpeg" class="img-fluid"></p>
<p>In the above, I actually haven’t entered any values.</p>
<p>I should also mention that even though Microsoft’s Azure Machine learning tool is cloud, web, and visually based- you can actually also include R scripts in the models you build. <strong>(There is a reason why R is popular as a statistical package).</strong></p>
<p>While I have not shown anything from it, yet another graphic tool that can be used for data mining is RapidMiner found at</p>
<p><a href="www.rapidminer.com">www.rapidminer.com</a></p>
</section>
</section>
<section id="conclusion" class="level1">
<h1>Conclusion</h1>
<p>In the previous blog article I wrote, I showed how discriminant analysis in the R statistics software could be used as a tool for job classification by showing how it could ‘predict’ a classification based on the features of the job classification description in question.</p>
<p>This blog article further expanded on that by showing that additional statistical tools in R such as decision trees and random forests could be used as well. And I have shown that the ability to use some of these statistical algorithms can be done in tools other than R- that are web based and menu driven and require no programming.</p>
<p>The whole point here is that, as I indicated in the introduction, ‘data driven’ analytical approaches can be applied to traditional HR methodologies. <strong>There is this ‘whole other world’ of HR that exists out there- capable of being rigorous and providing insights into our data, that simple HR reporting can’t.</strong> But it does require HR practitioners to pick up better information technology and statistical skills to obtain the benefits of it. I picked job classification from HR as an example to illustrate, but machine learning/predictive modelling can probably be used in ways that are only limited by the imagination.</p>
<p>In an upcoming blog article I will talk about how ‘data driven’ can be applied to HR Operations.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>